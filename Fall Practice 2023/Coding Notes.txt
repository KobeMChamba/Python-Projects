10/1
Lego Blocks
Problem requirements:
Calculate the number of ways an nxm wall can be built with 1x1, 1x2, 1x3, 1x4 blocks
Walls may not have vertical breaks or holes
 
Solution:
Create a base case for combinations of 1x0,1x1,1x2,1x3 walls
Sum last 4 cases of the wall and append to end of the list
continue to do so until list has the number of combinations for an m sized wall of height 1

Calculate combinations for N tall wall
set combinations to nth power for each width

Remove unstable combinations
No holes in our combinations, only need to find vertical breaks
No unstable combinations in 1x0 or 1x1

10/9
Weighted Uniform Strings
Problem requirements:
For each value in queries, return yes or no, depending on if the value is equal to any of the possible string weights. 
String weights are equal to the length of a uniform subset of characters where their weight is 1 for a, 2 for b, etc.

Solution: 
Hard code letter values
Compare each letter to the previous letter
if equal, increase counter
if not, add to dictionary if the value is greater than the existing value (replacing bb with bbb aka {b: 2} with {b: 3})
If there was only one letter: add it to dictionary
If it was the last letter: add it to dictionary (include previous checks)
Then go through queries and check for divisibility and sufficient length of strength
Return answers

What I learned:
Practiced use of dictionaries and iterating through list

Improvements to code:
I do not have to hardcode weights, could calculate them easily
Could store weight and length in the dictionary so i wouldnt need two dictionaries
Could check current character with next character and then just add the last one in


10/15 
Permutation Game
Problem requirements: Figure out if player 1 or 2 wins game when given list of numbers
Player wins by creating a list in increasing order, each player can remove one element at a time, assume players play optimally

Solution:
Create a function that checks if list is in increasing order
Create a memoization dictionary
Use recursive function "Find Winner"
Is boolean function: True means that after removing whatever index was removed, that player has forced a win state
If you get to that state that means that the previous state is false for the other state. So if on move one, P1 can force
win with one move, it returns true for subarray, therefore the full array is false. Therefore, returning false for the array
means that P1 won, returning false -> P1 Win, returning true -> P2 win
1) If increasing, base case, add True, add to memo
2) Calculate the next turn
3) For each element, remove it from array and call Find Winner
4) Check base case and memo, if True, the previous array is False
5) If none of the removals result in a True, then the prev array is True

What I learned:
More experience with dynamic programming
Using recursion to break down each problem to a base case
Add base case to the memo dictionary to increase efficiency
Use True and False to keep track of winner of each state and then using that to return winner for entire state.


